# V2StreamCap 项目技术指南

## 📋 项目概述

**V2StreamCap (StreamCap)** 是一个基于 Python 的多平台直播流录制客户端，支持 40+ 国内外主流直播平台（抖音、快手、虎牙、斗鱼、B站、TikTok等）。核心功能包括：
- 实时监控直播间状态
- 自动录制直播视频
- 捕获弹幕和互动信息
- 自动转码和消息推送

---

## 🏗️ 系统架构

```
┌─────────────────────────────────────────────────────────┐
│                   用户界面层 (UI Layer)                   │
│    Flet框架 + 导航栏 + 录制卡片 + 设置页面 + 存储管理      │
├─────────────────────────────────────────────────────────┤
│                  应用管理层 (App Layer)                   │
│  App Manager → 生命周期管理、页面路由、配置加载           │
├─────────────────────────────────────────────────────────┤
│                  业务逻辑层 (Business Layer)              │
│  RecordManager     │  BarrageManager  │  StreamManager   │
│  录制任务管理       │  弹幕数据管理     │  视频流录制       │
├─────────────────────────────────────────────────────────┤
│                  平台适配层 (Adapter Layer)               │
│  DouyinHandler │ TikTokHandler │ HuyaHandler │ 40+ ...   │
│  平台特定逻辑   │  获取流地址   │  解析直播信息             │
├─────────────────────────────────────────────────────────┤
│                  底层工具层 (Infrastructure Layer)        │
│  FFmpeg录制引擎 │ StreamGet库 │ WebSocket连接 │ Protobuf解析 │
└─────────────────────────────────────────────────────────┘
```

### 架构说明

#### 1. 用户界面层 (UI Layer)
- **技术栈**：Flet (基于Flutter的Python UI框架)
- **职责**：提供跨平台的图形用户界面
- **核心组件**：
  - `NavigationSidebar`：左侧导航栏
  - `RecordingCard`：录制任务卡片
  - `SettingsPage`：设置页面
  - `StoragePage`：存储管理页面

#### 2. 应用管理层 (App Layer)
- **核心类**：`App` (app_manager.py)
- **职责**：
  - 应用生命周期管理
  - 页面路由控制
  - 配置加载与保存
  - 依赖检查（FFmpeg、Node.js）
  - 软件更新检查

#### 3. 业务逻辑层 (Business Layer)
- **RecordingManager**：管理所有录制任务
- **BarrageManager**：管理弹幕录制
- **StreamManager**：管理视频流录制
- **ConfigManager**：配置文件管理
- **LanguageManager**：多语言支持

#### 4. 平台适配层 (Adapter Layer)
- 为每个直播平台提供统一的接口
- 封装平台特定的API调用
- 支持40+平台（抖音、快手、B站、TikTok等）

#### 5. 底层工具层 (Infrastructure Layer)
- **FFmpeg**：视频录制和转码引擎
- **StreamGet**：多平台流媒体地址解析库
- **WebSocket**：实时弹幕连接
- **Protobuf**：二进制消息解析

---

## 🔄 核心工作流程

### 1. 应用启动流程

```
启动 main.py
    ↓
加载环境变量 (.env)
    ↓
初始化 Flet UI框架
    ↓
创建 App Manager
    ├─ 加载配置管理器 (ConfigManager)
    ├─ 加载语言管理器 (LanguageManager) 
    ├─ 初始化录制管理器 (RecordingManager)
    ├─ 初始化弹幕管理器 (BarrageManager)
    ├─ 检查依赖环境 (FFmpeg/Node.js)
    └─ 检查软件更新 (UpdateChecker)
    ↓
渲染主界面
    ├─ 左侧导航栏
    ├─ 录制卡片区域
    └─ 设置/存储/关于页面
    ↓
从 recordings.json 加载历史任务
    ↓
等待用户操作
```

#### 代码入口（main.py）

主函数负责：
1. 解析命令行参数（--web, --host, --port）
2. 判断运行模式（桌面/Web）
3. 初始化窗口配置
4. 启动Flet应用

关键代码逻辑：
- 支持环境变量配置（PLATFORM, HOST, PORT）
- 桌面模式：自动调整窗口大小（屏幕尺寸的65%）
- Web模式：监听指定端口（默认6006）

### 2. 添加录制任务流程

```
用户点击"添加录制"按钮
    ↓
弹出录制对话框 (RecordingDialog)
    ├─ 输入：直播间URL
    ├─ 选择：视频质量 (原画/超清/高清/标清)
    ├─ 选择：保存格式 (mp4/flv/ts/mkv等)
    ├─ 配置：分段录制时长
    └─ 设置：输出目录
    ↓
平台识别 (通过URL自动检测平台类型)
    ↓
创建 Recording 对象
    ├─ 生成唯一ID (UUID)
    ├─ 保存配置信息
    └─ 初始状态：未监控
    ↓
添加到录制列表 (recordings)
    ↓
持久化到 recordings.json
    ↓
创建录制卡片 (RecordingCard) 并显示在界面
```

#### Recording 对象结构

```python
{
    "rec_id": "uuid",              # 唯一标识
    "live_url": "直播间URL",       # 直播地址
    "platform": "douyin",          # 平台类型
    "quality": "origin",           # 视频质量
    "save_format": "mp4",          # 保存格式
    "output_dir": "downloads/",    # 输出目录
    "streamer_name": "主播名称",   # 主播名称
    "monitor_status": false,       # 监控状态
    "is_recording": false,         # 录制状态
    "segment_record": false,       # 分段录制
    "segment_time": "1800"         # 分段时长(秒)
}
```

### 3. 监控录制流程（最核心）

```
用户点击"开始监控"
    ↓
【RecordingManager.start_monitor_recording】
    ├─ 更新任务状态：monitor_status = True
    ├─ 显示状态：正在监控...
    └─ 启动异步任务 check_if_live
        ↓
【循环检测直播状态】
while 监控状态为True:
    ↓
    获取平台处理器 (PlatformHandler)
    ├─ 抖音 → DouyinHandler
    ├─ 快手 → KuaishouHandler
    ├─ B站 → BilibiliHandler
    └─ 其他平台...
    ↓
    调用 get_stream_info(live_url)
    ├─ 使用 StreamGet 库获取直播信息
    ├─ 返回 StreamData 对象：
    │   ├─ is_live：是否在播
    │   ├─ stream_url：流媒体地址
    │   ├─ title：直播标题
    │   ├─ anchor_name：主播名称
    │   └─ platform：平台名称
    ↓
    判断直播状态
    ├─ [未开播] → 等待 loop_time_seconds (默认300秒)
    │              → 继续循环检测
    │
    └─ [正在直播] → 启动录制流程
        ↓
【开始录制 LiveStreamRecorder】
    ↓
    1. 构建文件名
       格式：主播名称_直播标题_2025-11-24_14-30-00
    ↓
    2. 创建输出目录
       可选层级：平台/主播/日期/标题
    ↓
    3. 启动弹幕录制 (如果开启)
       └─ BarrageManager.start_recording
           ├─ 连接 WebSocket (抖音平台)
           ├─ 接收实时弹幕数据
           ├─ 解析 Protobuf 消息
           └─ 写入弹幕文本文件
    ↓
    4. 构建 FFmpeg 命令
       └─ FFmpegBuilder 根据配置生成：
           ├─ 输入参数：-i {stream_url}
           ├─ 编码参数：-c copy (直接复制流)
           ├─ 分段参数：-f segment -segment_time 1800
           ├─ 格式参数：-f {save_format}
           └─ 输出路径：{output_dir}/{filename}.{format}
    ↓
    5. 启动 FFmpeg 进程
       └─ subprocess.Popen(ffmpeg_cmd)
           ├─ 注册到 ProcessManager
           ├─ 实时读取stdout/stderr
           └─ 监控录制状态
    ↓
    6. 更新UI状态
       ├─ 显示：正在录制...
       ├─ 实时更新文件大小
       └─ 显示录制时长
    ↓
    7. 循环检测直播状态
       每60秒检查一次：
       ├─ [仍在直播] → 继续录制
       └─ [直播结束] → 停止录制
           ↓
【录制结束处理】
    ↓
    1. 终止 FFmpeg 进程
    ↓
    2. 停止弹幕录制
    ↓
    3. 检查是否开启自动转码
       └─ [开启] → 启动转码任务
           ├─ FFmpeg 转码为 MP4
           ├─ 编码：H.264 + AAC
           └─ 删除原始文件（可选）
    ↓
    4. 消息推送（如果配置）
       └─ MessagePusher 发送通知：
           ├─ 主播：xxx
           ├─ 标题：xxx
           └─ 文件大小：xxx MB
    ↓
    5. 更新录制历史记录
    ↓
    6. 恢复监控状态，继续循环检测
```

#### 关键代码模块

**RecordingManager.check_if_live()**
- 职责：循环检测直播状态
- 检测间隔：用户配置（默认300秒）
- 错误处理：重试机制和日志记录

**LiveStreamRecorder.start_recording()**
- 职责：启动FFmpeg录制进程
- 文件命名：支持多种命名规则
- 目录结构：支持多层级分类

**ProcessManager**
- 职责：管理所有FFmpeg子进程
- 清理机制：应用退出时优雅关闭所有进程
- 进程监控：检测异常退出并记录

---

## 🎨 关键模块详解

### A. 弹幕捕获模块（抖音平台示例）

#### 技术架构

```
【StreamCapDouyinFetcher】
    ↓
1. 生成签名
   ├─ 提取URL参数 (live_id, room_id等)
   ├─ 参数序列化
   ├─ MD5哈希
   └─ 调用JS签名算法 (py_mini_racer)
    ↓
2. 建立WebSocket连接
   wss://webcast3-ws-web-lf.douyin.com/webcast/im/push/v2/
    ↓
3. 心跳维护
   每5秒发送 PING 帧
    ↓
4. 接收消息
   ├─ 解析 PushFrame 外层
   ├─ Gzip 解压缩
   ├─ 解析 Response 对象
   └─ 遍历 messages_list
    ↓
5. 消息分发
   ├─ WebcastChatMessage → 聊天弹幕
   ├─ WebcastGiftMessage → 礼物消息
   ├─ WebcastMemberMessage → 进场消息
   ├─ WebcastLikeMessage → 点赞消息
   └─ WebcastLiveShoppingMessage → 购物行为（核心）
    ↓
6. 写入文件
   保存到 {output_dir}/{filename}_弹幕.txt
```

#### 核心技术点

**1. WebSocket 连接机制**

- **协议**：wss:// (WebSocket Secure)
- **连接库**：websocket-client
- **断线重连**：指数退避算法
- **并发控制**：每个录制任务独立连接

**2. 签名生成机制**

抖音平台需要动态签名验证：

```python
# 签名流程
参数提取 → MD5哈希 → JS算法 → 最终签名
```

使用 `py_mini_racer` 嵌入V8引擎执行官方JS代码：
```python
from py_mini_racer import MiniRacer
ctx = MiniRacer()
ctx.eval(open('sign.js').read())
signature = ctx.call('get_sign', md5_hash)
```

**优势**：
- 避免逆向签名算法
- 算法更新时只需替换JS文件
- 兼容性好

**3. Protobuf 消息解析**

消息结构：
```
WebSocket原始数据
    ↓
PushFrame (外层容器)
    ├─ log_id: 消息ID
    ├─ payload_type: 消息类型
    ├─ payload: 压缩的数据
    └─ need_ack: 是否需要确认
        ↓
Gzip解压缩
    ↓
Response (响应对象)
    ├─ messages_list: 消息列表
    ├─ cursor: 游标
    └─ fetch_interval: 拉取间隔
        ↓
Message (具体消息)
    ├─ method: 消息类型名称
    └─ payload: 消息体数据
        ↓
具体消息类型解析
    ├─ ChatMessage: 聊天内容
    ├─ GiftMessage: 礼物信息
    ├─ MemberMessage: 用户进场
    └─ ...
```

**4. 心跳与ACK机制**

**心跳包**（保持连接活跃）：
- 间隔：5秒
- 格式：PushFrame(payload_type='hb')
- 方式：PING帧

**ACK确认**（关键消息确认）：
```python
if response.need_ack:
    ack_frame = PushFrame(
        log_id=original_log_id,
        payload_type='ack',
        payload=response.internal_ext
    )
    ws.send(ack_frame.SerializeToString())
```

**5. 消息去重机制**

防止重复消息：
```python
self._message_cache = {}  # 缓存最近的消息
self._cache_timeout = 2   # 2秒内的重复消息忽略

def is_duplicate(msg_id, timestamp):
    if msg_id in self._message_cache:
        if current_time - timestamp < self._cache_timeout:
            return True
    self._message_cache[msg_id] = timestamp
    return False
```

**6. 弹幕文件格式**

```
[2025-11-24 14:30:15] 用户昵称: 弹幕内容
[2025-11-24 14:30:20] [礼物] 用户A 送出 小心心 x 10
[2025-11-24 14:30:25] [进场] 用户B 进入直播间
[2025-11-24 14:30:30] [关注] 用户C 关注了主播
[2025-11-24 14:30:35] [下单] 用户D 购买了商品 (商品ID: 12345)
```

#### BarrageManager 核心方法

**start_recording()**
- 创建弹幕文件
- 启动WebSocket连接
- 注册回调函数

**stop_recording()**
- 关闭WebSocket连接
- 刷新文件缓冲区
- 关闭文件句柄

**write_to_file()**
- 格式化消息
- 追加写入文件
- 实时刷新

### B. FFmpeg 录制引擎

#### 核心命令示例

**基础录制命令**：
```bash
ffmpeg -i "https://pull-flv-l1.douyincdn.com/live/xxx.flv" \
       -c copy \
       -f mp4 \
       "output.mp4"
```

**分段录制命令**：
```bash
ffmpeg -i "https://xxx.flv" \
       -c copy \
       -f segment \
       -segment_time 1800 \
       -reset_timestamps 1 \
       -strftime 1 \
       -f mp4 \
       "output_%Y%m%d_%H%M%S.mp4"
```

**参数详解**：

| 参数 | 说明 | 作用 |
|------|------|------|
| `-i` | 输入源 | 指定流媒体URL |
| `-c copy` | 编码器 | 直接复制流（不重新编码，高效） |
| `-f segment` | 输出格式 | 分段输出 |
| `-segment_time 1800` | 分段时长 | 每30分钟一段 |
| `-reset_timestamps 1` | 时间戳重置 | 每段从0开始 |
| `-strftime 1` | 时间格式化 | 文件名支持时间格式 |
| `-f mp4` | 容器格式 | 输出MP4格式 |

#### FFmpeg Builder 架构

项目采用**建造者模式**构建FFmpeg命令：

```
app/core/ffmpeg_builders/
├── base.py                    # 基础构建器
├── video/
│   ├── video_builder.py       # 视频录制构建器
│   ├── segment_builder.py     # 分段录制构建器
│   └── transcode_builder.py   # 转码构建器
└── audio/
    ├── audio_builder.py       # 音频录制构建器
    └── audio_format_builder.py # 音频格式构建器
```

**VideoBuilder 示例**：

```python
class VideoBuilder(FFmpegBaseBuilder):
    def build(self):
        cmd = [self.ffmpeg_path]
        cmd.extend(self._build_input_args())
        cmd.extend(self._build_codec_args())
        cmd.extend(self._build_format_args())
        cmd.extend(self._build_output_args())
        return cmd
    
    def _build_input_args(self):
        return ['-i', self.stream_url]
    
    def _build_codec_args(self):
        if self.transcode:
            return ['-c:v', 'libx264', '-c:a', 'aac']
        return ['-c', 'copy']
    
    def _build_format_args(self):
        if self.segment:
            return [
                '-f', 'segment',
                '-segment_time', str(self.segment_time),
                '-reset_timestamps', '1'
            ]
        return ['-f', self.format]
```

#### 进程管理

**AsyncProcessManager**：
- 管理所有FFmpeg子进程
- 异步清理机制
- 进程状态监控

```python
class AsyncProcessManager:
    def __init__(self):
        self.processes = []
        self.lock = asyncio.Lock()
    
    def add_process(self, process):
        self.processes.append(process)
    
    async def cleanup(self):
        async with self.lock:
            for process in self.processes:
                if process.poll() is None:
                    process.terminate()
                    await asyncio.sleep(0.5)
                    if process.poll() is None:
                        process.kill()
```

#### 录制监控

实时监控FFmpeg输出：
```python
def monitor_ffmpeg_output(process):
    while True:
        line = process.stderr.readline()
        if not line:
            break
        # 解析输出信息
        # frame=1234 fps=25 size=12345kB time=00:05:30
        if 'frame=' in line:
            parse_progress(line)
        if 'error' in line.lower():
            log_error(line)
```

### C. 平台适配层

#### 统一接口设计

**PlatformHandler 基类**：
```python
class PlatformHandler:
    def __init__(self, proxy, cookies, record_quality, platform):
        self.proxy = proxy
        self.cookies = cookies
        self.record_quality = record_quality
        self.platform = platform
    
    async def get_stream_info(self, live_url) -> StreamData:
        """获取直播流信息（抽象方法）"""
        raise NotImplementedError
```

**StreamData 数据类**：
```python
@dataclass
class StreamData:
    is_live: bool           # 是否正在直播
    stream_url: str         # 流媒体地址
    title: str              # 直播标题
    anchor_name: str        # 主播名称
    platform: str           # 平台名称
    quality: str            # 视频质量
```

#### 平台实现示例

**DouyinHandler**（抖音）：
```python
class DouyinHandler(PlatformHandler):
    async def get_stream_info(self, live_url):
        self.live_stream = streamget.DouyinLiveStream(
            proxy_addr=self.proxy,
            cookies=self.cookies
        )
        
        # 区分移动端和网页端链接
        if "v.douyin.com" in live_url:
            json_data = await self.live_stream.fetch_app_stream_data(url=live_url)
        else:
            json_data = await self.live_stream.fetch_web_stream_data(url=live_url)
        
        return await self.live_stream.fetch_stream_url(
            json_data, 
            self.record_quality
        )
```

**BilibiliHandler**（B站）：
```python
class BilibiliHandler(PlatformHandler):
    async def get_stream_info(self, live_url):
        self.live_stream = streamget.BilibiliLiveStream(
            proxy_addr=self.proxy,
            cookies=self.cookies
        )
        json_data = await self.live_stream.fetch_web_stream_data(url=live_url)
        return await self.live_stream.fetch_stream_url(
            json_data,
            self.record_quality
        )
```

#### 平台识别机制

通过URL自动识别平台：
```python
def get_platform_info(live_url, platform, **kwargs):
    """工厂方法：根据URL返回对应的处理器"""
    
    # URL关键词映射
    platform_map = {
        'douyin.com': 'douyin',
        'tiktok.com': 'tiktok',
        'kuaishou.com': 'kuaishou',
        'huya.com': 'huya',
        'douyu.com': 'douyu',
        'bilibili.com': 'bilibili',
        # ... 更多平台
    }
    
    # 识别平台
    for keyword, platform_name in platform_map.items():
        if keyword in live_url:
            platform = platform_name
            break
    
    # 返回对应处理器
    handler_class = PLATFORM_HANDLERS.get(platform)
    return handler_class(**kwargs)
```

### D. 配置管理系统

#### 配置文件结构

```
config/
├── user_settings.json         # 用户配置
├── recordings.json            # 录制任务列表
├── accounts.json              # 平台账号配置
├── cookies.json               # Cookie配置
├── language.json              # 多语言配置
└── version.json               # 版本信息
```

#### user_settings.json 结构

```json
{
  "output_dir": "downloads",
  "loop_time_seconds": 300,
  "enable_transcode": true,
  "filename_includes_title": true,
  "folder_name_platform": true,
  "folder_name_author": true,
  "folder_name_time": false,
  "auto_record_barrage": true,
  "enable_proxy": false,
  "proxy_address": "",
  "default_platform_with_proxy": "tiktok,youtube",
  "segment_record": false,
  "segment_time": "1800",
  "default_quality": "origin",
  "default_format": "mp4",
  "theme": "light",
  "language": "zh_CN"
}
```

#### recordings.json 结构

```json
[
  {
    "rec_id": "550e8400-e29b-41d4-a716-446655440000",
    "live_url": "https://live.douyin.com/745964462470",
    "platform": "douyin",
    "platform_key": "douyin",
    "streamer_name": "主播名称",
    "quality": "origin",
    "save_format": "mp4",
    "output_dir": "downloads/抖音",
    "monitor_status": false,
    "is_recording": false,
    "segment_record": true,
    "segment_time": "1800",
    "auto_transcode": true,
    "record_barrage": true,
    "created_at": "2025-11-24 14:30:00",
    "last_check_time": "2025-11-24 15:00:00",
    "recording_dir": "downloads/抖音/主播名称/2025-11-24"
  }
]
```

#### ConfigManager 核心方法

```python
class ConfigManager:
    def __init__(self, run_path):
        self.config_dir = os.path.join(run_path, "config")
        self.ensure_config_files()
    
    async def load_user_config(self):
        """加载用户配置"""
        file_path = os.path.join(self.config_dir, "user_settings.json")
        return await self._load_json(file_path)
    
    async def save_user_config(self, config):
        """保存用户配置"""
        file_path = os.path.join(self.config_dir, "user_settings.json")
        await self._save_json(file_path, config)
    
    async def load_recordings_config(self):
        """加载录制任务配置"""
        file_path = os.path.join(self.config_dir, "recordings.json")
        return await self._load_json(file_path)
    
    async def save_recordings_config(self, recordings):
        """保存录制任务配置"""
        file_path = os.path.join(self.config_dir, "recordings.json")
        await self._save_json(file_path, recordings)
```

#### 配置热更新

支持配置实时更新，无需重启应用：
```python
class SettingsPage:
    async def save_settings(self):
        # 更新配置
        self.user_config.update(new_settings)
        
        # 保存到文件
        await self.config_manager.save_user_config(self.user_config)
        
        # 通知其他模块
        self.app.record_manager.load()
        self.app.language_manager.load()
        
        # 更新UI
        self.page.update()
```

---

## 📊 数据流图

### 整体数据流

```
用户操作
    ↓
    ↓ 添加任务
    ↓
┌───────────────────┐
│  RecordingManager │ ← 任务管理
└─────────┬─────────┘
          │
          ↓ 监控循环
          │
┌─────────▼──────────┐
│ PlatformHandler    │ ← 平台适配
│ (获取直播信息)      │
└─────────┬──────────┘
          │
          ↓ 流地址
          │
┌─────────▼───────────┐
│ LiveStreamRecorder  │ ← 视频录制
│ (FFmpeg进程)        │
└─────────┬───────────┘
          │
          ↓ 视频文件
          │
┌─────────▼───────────┐
│   本地存储           │
│   downloads/平台/    │
└─────────────────────┘
          │
          ↓ (可选)
          │
┌─────────▼───────────┐
│  自动转码 MP4       │
└─────────────────────┘
          │
          ↓
┌─────────▼───────────┐
│  消息推送通知       │
└─────────────────────┘
```

### 弹幕数据流

```
抖音服务器
    ↓ WebSocket
    ↓ 推送消息
    ↓
┌─────────────────────┐
│ StreamCapDouyinFetcher │
│ (WebSocket客户端)      │
└──────────┬──────────┘
           │
           ↓ 原始二进制数据
           │
┌──────────▼──────────┐
│  Protobuf解析器      │
│  (PushFrame/Response)│
└──────────┬──────────┘
           │
           ↓ 消息对象
           │
┌──────────▼──────────┐
│  消息分发器          │
│  (按类型路由)        │
└──────────┬──────────┘
           │
           ↓ 回调通知
           │
┌──────────▼──────────┐
│  BarrageManager     │
│  (格式化+写入文件)   │
└──────────┬──────────┘
           │
           ↓ 文本数据
           │
┌──────────▼──────────┐
│  弹幕文件.txt       │
└─────────────────────┘
```

---

## 🔧 技术栈

### 核心依赖

| 类别 | 技术 | 版本 | 用途 |
|------|------|------|------|
| **UI框架** | Flet | 0.27.6 | 跨平台桌面应用界面（基于Flutter） |
| **视频处理** | FFmpeg | - | 视频录制、转码、格式转换 |
| **流媒体** | StreamGet | ≥4.0.5 | 多平台流地址解析库 |
| **HTTP客户端** | httpx | ≥0.28.1 | 异步HTTP请求 |
| **WebSocket** | websocket-client | 1.7.0 | WebSocket连接 |
| **消息序列化** | betterproto | 2.0.0b6 | Protobuf解析 |
| **JS引擎** | py_mini_racer | 0.12.4 | 执行JavaScript签名算法 |
| **JS引擎(备选)** | PyExecJS | 1.5.1 | JavaScript执行环境 |
| **异步IO** | aiofiles | ≥24.1.0 | 异步文件操作 |
| **配置管理** | python-dotenv | ≥1.0.1 | 环境变量管理 |
| **屏幕信息** | screeninfo | ≥0.8.1 | 获取屏幕尺寸 |
| **HTTP请求** | requests | 2.31.0 | 同步HTTP请求 |

### 项目结构

```
V2StreamCap/
├── app/                          # 应用主目录
│   ├── __init__.py
│   ├── app_manager.py            # 应用管理器
│   ├── installation_manager.py   # 依赖安装管理
│   ├── process_manager.py        # 进程管理器
│   │
│   ├── core/                     # 核心模块
│   │   ├── config_manager.py     # 配置管理
│   │   ├── language_manager.py   # 多语言支持
│   │   ├── record_manager.py     # 录制管理
│   │   ├── stream_manager.py     # 流管理
│   │   ├── barrage_manager.py    # 弹幕管理
│   │   ├── update_checker.py     # 更新检查
│   │   │
│   │   ├── ffmpeg_builders/      # FFmpeg命令构建器
│   │   │   ├── base.py           # 基础构建器
│   │   │   ├── video/            # 视频构建器
│   │   │   └── audio/            # 音频构建器
│   │   │
│   │   └── platform_handlers/    # 平台处理器
│   │       ├── base.py           # 基础处理器
│   │       └── handlers.py       # 40+平台实现
│   │
│   ├── douyin_fetcher/           # 抖音弹幕抓取
│   │   ├── liveMan.py            # 核心抓取逻辑
│   │   ├── streamcap_adapter.py  # 适配器
│   │   ├── sign.js               # 签名算法
│   │   └── protobuf/             # Protobuf定义
│   │       ├── douyin.proto      # 消息定义
│   │       └── douyin_pb2.py     # 生成的Python代码
│   │
│   ├── ui/                       # 用户界面
│   │   ├── base_page.py          # 页面基类
│   │   ├── views/                # 页面视图
│   │   │   ├── home_view.py      # 首页
│   │   │   ├── settings_view.py  # 设置页
│   │   │   ├── storage_view.py   # 存储页
│   │   │   └── about_view.py     # 关于页
│   │   ├── components/           # UI组件
│   │   │   ├── recording_card.py # 录制卡片
│   │   │   ├── recording_dialog.py # 录制对话框
│   │   │   └── ...
│   │   ├── navigation/           # 导航组件
│   │   └── themes/               # 主题配置
│   │
│   ├── models/                   # 数据模型
│   │   ├── recording_model.py    # 录制任务模型
│   │   ├── video_quality_model.py # 视频质量模型
│   │   └── recording_status_model.py # 录制状态模型
│   │
│   ├── messages/                 # 消息推送
│   │   ├── message_pusher.py     # 消息推送器
│   │   └── notification_service.py # 通知服务
│   │
│   ├── scripts/                  # 安装脚本
│   │   ├── ffmpeg_install.py     # FFmpeg安装
│   │   └── node_install.py       # Node.js安装
│   │
│   └── utils/                    # 工具函数
│       ├── logger.py             # 日志记录
│       ├── utils.py              # 通用工具
│       └── delay.py              # 延迟工具
│
├── config/                       # 配置文件
│   ├── user_settings.json        # 用户配置
│   ├── recordings.json           # 录制任务
│   ├── accounts.json             # 账号配置
│   ├── cookies.json              # Cookie配置
│   └── language.json             # 语言配置
│
├── locales/                      # 多语言文件
│   ├── zh_CN.json                # 简体中文
│   └── en.json                   # 英语
│
├── assets/                       # 资源文件
│   ├── icon.ico                  # 应用图标
│   ├── fonts/                    # 字体文件
│   └── images/                   # 图片资源
│
├── downloads/                    # 下载目录（默认）
│   └── 平台名称/
│       └── 主播名称/
│           └── 视频文件
│
├── logs/                         # 日志文件
│   ├── streamget.log             # 录制日志
│   └── play_url.log              # 播放URL日志
│
├── main.py                       # 程序入口
├── requirements.txt              # 依赖列表
├── pyproject.toml                # 项目配置
├── .env                          # 环境变量
├── Dockerfile                    # Docker配置
└── docker-compose.yml            # Docker Compose配置
```

---

## 🚀 部署与运行

### 1. 桌面模式（Windows/macOS）

#### 方式A：使用预编译版本

```bash
# 1. 下载对应平台的安装包
# Windows: StreamCap.zip
# macOS: StreamCap.dmg

# 2. 解压/安装后直接运行
StreamCap.exe  # Windows
# 或在启动台打开 StreamCap（macOS）
```

#### 方式B：从源码运行

```bash
# 1. 克隆项目
git clone https://github.com/ihmily/StreamCap.git
cd StreamCap

# 2. 创建虚拟环境（推荐）
python -m venv venv
source venv/bin/activate  # Linux/macOS
venv\Scripts\activate     # Windows

# 3. 安装依赖
pip install -r requirements.txt

# 4. 配置环境变量（可选）
cp .env.example .env
# 编辑 .env 文件

# 5. 运行应用
python main.py
```

### 2. Web模式（Linux或远程访问）

```bash
# 方式A：命令行参数
python main.py --web --host 0.0.0.0 --port 6006

# 方式B：环境变量配置
# 编辑 .env 文件
# PLATFORM=web
# HOST=0.0.0.0
# PORT=6006

python main.py

# 访问地址
# 本地：http://127.0.0.1:6006
# 远程：http://服务器IP:6006
```

### 3. Docker模式

#### 使用Docker Compose（推荐）

```bash
# 1. 确保已安装 Docker 和 Docker Compose

# 2. 创建 .env 文件（如果不存在）
cp .env.example .env

# 3. 启动容器
docker compose up -d

# 4. 查看日志
docker compose logs -f

# 5. 停止容器
docker compose stop

# 6. 删除容器
docker compose down
```

#### 使用Docker命令

```bash
# 1. 拉取镜像
docker pull ihmily/streamcap:latest

# 2. 运行容器
docker run -d \
  --name streamcap \
  -p 6006:6006 \
  -v $(pwd)/downloads:/app/downloads \
  -v $(pwd)/config:/app/config \
  -v $(pwd)/logs:/app/logs \
  -e PLATFORM=web \
  -e HOST=0.0.0.0 \
  -e PORT=6006 \
  -e TZ=Asia/Shanghai \
  ihmily/streamcap:latest

# 3. 查看日志
docker logs -f streamcap

# 4. 停止容器
docker stop streamcap

# 5. 删除容器
docker rm streamcap
```

#### 自定义构建镜像

```bash
# 构建镜像
docker build -t streamcap:custom .

# 运行自定义镜像
docker run -d \
  --name streamcap \
  -p 6006:6006 \
  -v $(pwd)/downloads:/app/downloads \
  streamcap:custom
```

### 4. 环境依赖

#### FFmpeg 安装

**Windows**：
```bash
# 方式1：应用内自动安装（推荐）
# 启动应用后会自动检测并提示安装

# 方式2：手动安装
# 1. 下载：https://ffmpeg.org/download.html
# 2. 解压到任意目录
# 3. 添加到系统PATH环境变量
```

**macOS**：
```bash
# 使用 Homebrew
brew install ffmpeg

# 验证安装
ffmpeg -version
```

**Linux**：
```bash
# Ubuntu/Debian
sudo apt update
sudo apt install ffmpeg

# CentOS/RHEL
sudo yum install ffmpeg

# 验证安装
ffmpeg -version
```

#### Node.js 安装（可选）

仅抖音平台某些功能需要：

```bash
# Windows
# 从应用内自动安装

# macOS
brew install node

# Linux
# Ubuntu/Debian
sudo apt install nodejs npm

# 验证安装
node --version
npm --version
```

---

## 🎯 使用场景示例

### 场景1：录制抖音直播

**步骤**：
1. 打开应用 → 点击"添加录制"
2. 输入直播间URL：`https://live.douyin.com/745964462470`
3. 选择画质：原画
4. 选择格式：MP4
5. 点击"开始监控"
6. 系统每5分钟检测一次
7. 检测到开播 → 自动开始录制
8. 同时捕获弹幕和礼物信息
9. 直播结束 → 自动停止
10. 转码为MP4 → 发送完成通知

**结果**：
```
downloads/抖音/主播名称/
├── 主播名称_直播标题_2025-11-24_14-30-00.mp4
└── 主播名称_直播标题_2025-11-24_14-30-00_弹幕.txt
```

### 场景2：批量监控多个主播

**步骤**：
1. 添加多个录制任务：
   - 抖音主播A
   - 快手主播B
   - B站主播C
   - 虎牙主播D
2. 全选任务
3. 点击"批量监控"
4. 系统并发检测所有直播间
5. 任何一个开播都会自动录制
6. 在"存储管理"页面查看所有录制文件

**优势**：
- 支持跨平台批量监控
- 自动化无人值守
- 节省时间和精力

### 场景3：定时录制（通过监控间隔配置）

**步骤**：
1. 进入"设置"页面
2. 设置"检测间隔"：60秒（更频繁）或600秒（更省资源）
3. 添加录制任务
4. 开始监控
5. 系统按设定间隔检测

**使用建议**：
- 重要直播：60秒（及时开始录制）
- 普通直播：300秒（平衡效率）
- 资源受限：600秒（降低负载）

### 场景4：分段录制长时间直播

**步骤**：
1. 添加录制任务
2. 勾选"分段录制"
3. 设置分段时长：1800秒（30分钟）
4. 开始监控

**结果**：
```
downloads/抖音/主播名称/
├── 主播名称_2025-11-24_14-00-00.mp4  # 第1段
├── 主播名称_2025-11-24_14-30-00.mp4  # 第2段
├── 主播名称_2025-11-24_15-00-00.mp4  # 第3段
└── ...
```

**优势**：
- 避免单文件过大
- 方便后期处理
- 降低录制失败风险

### 场景5：捕获电商直播下单行为

**特殊功能**（抖音平台）：
1. 添加抖音直播录制任务
2. 确保开启"弹幕录制"
3. 开始监控

**捕获内容**：
```
[2025-11-24 14:30:15] 用户A: 这个多少钱？
[2025-11-24 14:30:20] [礼物] 用户B 送出 小心心 x 10
[2025-11-24 14:30:25] [下单] 用户C 购买了商品 (商品ID: 12345)
[2025-11-24 14:30:30] [商品变更] 商品12345 库存更新
```

**应用场景**：
- 电商数据分析
- 用户行为研究
- 营销效果评估

---

## 📖 高级配置

### 1. 代理配置

支持通过代理访问海外平台：

```json
// config/user_settings.json
{
  "enable_proxy": true,
  "proxy_address": "http://127.0.0.1:7890",
  "default_platform_with_proxy": "tiktok,youtube,twitch"
}
```

### 2. Cookie 配置

某些平台需要登录才能访问：

```json
// config/cookies.json
{
  "douyin": "sessionid=xxx; __ac_nonce=xxx; ...",
  "bilibili": "SESSDATA=xxx; bili_jct=xxx; ...",
  "youtube": "cookies字符串"
}
```

**获取Cookie方法**：
1. 浏览器打开直播平台
2. F12打开开发者工具
3. 切换到"网络"标签
4. 刷新页面
5. 找到请求头中的Cookie
6. 复制完整Cookie字符串

### 3. 账号配置

某些平台需要账号信息：

```json
// config/accounts.json
{
  "platform_name": {
    "username": "账号",
    "password": "密码"
  }
}
```

### 4. 消息推送配置

支持多种推送方式：
- Webhook
- 邮件
- Telegram
- 企业微信
- 钉钉

```json
// config/user_settings.json
{
  "enable_notification": true,
  "notification_type": "webhook",
  "webhook_url": "https://your-webhook-url.com/notify"
}
```

### 5. 文件命名规则

自定义文件名格式：

```json
{
  "filename_includes_title": true,    // 包含直播标题
  "folder_name_platform": true,       // 按平台分类
  "folder_name_author": true,         // 按主播分类
  "folder_name_time": true,           // 按日期分类
  "folder_name_title": false          // 按标题分类
}
```

**示例目录结构**：
```
downloads/
└── 抖音/                    # 平台
    └── 主播名称/             # 主播
        └── 2025-11-24/      # 日期
            └── 主播名称_直播标题_14-30-00.mp4
```

### 6. 视频质量映射

不同平台的画质选项：

| 平台 | 原画 | 超清 | 高清 | 标清 |
|------|------|------|------|------|
| 抖音 | origin | uhd | hd | sd |
| B站 | 原画 | 蓝光 | 超清 | 高清 |
| 快手 | origin | high | normal | low |

配置示例：
```python
VideoQuality.ORIGIN  # 原画
VideoQuality.UHD     # 超清
VideoQuality.HD      # 高清
VideoQuality.SD      # 标清
VideoQuality.LD      # 流畅
```

---

## 🐛 常见问题与故障排除

### 问题1：提示缺少FFmpeg

**解决方案**：
```bash
# Windows: 应用内自动安装
# 或手动下载：https://ffmpeg.org/download.html

# macOS
brew install ffmpeg

# Linux
sudo apt install ffmpeg
```

### 问题2：无法连接到直播间

**可能原因**：
- 直播间URL错误
- 网络连接问题
- 平台反爬虫限制

**解决方案**：
1. 检查URL是否正确
2. 检查网络连接
3. 配置Cookie
4. 使用代理
5. 查看日志：`logs/streamget.log`

### 问题3：弹幕录制失败（抖音）

**可能原因**：
- 缺少Node.js环境
- 签名算法失效

**解决方案**：
1. 安装Node.js
2. 检查 `douyin_fetcher/sign.js` 是否最新
3. 查看日志：`logs/play_url.log`

### 问题4：录制文件损坏

**可能原因**：
- 直播中断
- 磁盘空间不足
- FFmpeg异常退出

**解决方案**：
1. 检查磁盘空间
2. 启用分段录制
3. 启用自动转码（修复可能的问题）

### 问题5：内存占用过高

**解决方案**：
1. 减少同时监控的任务数量
2. 增加检测间隔时间
3. 关闭不必要的弹幕录制
4. 使用分段录制

### 问题6：Docker容器无法启动

**检查步骤**：
```bash
# 查看容器日志
docker logs streamcap

# 检查端口占用
netstat -an | grep 6006

# 检查磁盘空间
df -h

# 重新构建镜像
docker compose build --no-cache
```

---

## 🔒 安全与隐私

### 1. 数据安全

- **配置文件**：所有配置保存在本地，不上传云端
- **Cookie**：存储在本地 `config/cookies.json`
- **日志**：仅记录必要信息，不包含敏感数据

### 2. 网络安全

- **代理支持**：保护隐私和绕过限制
- **HTTPS**：所有API请求使用HTTPS
- **WebSocket**：使用WSS加密连接

### 3. 使用建议

- 定期清理日志文件
- 不要分享配置文件
- 使用强密码保护账号
- 遵守平台服务条款

---

## 📈 性能优化建议

### 1. 监控策略

**推荐配置**：
- 1-5个任务：检测间隔60秒
- 6-15个任务：检测间隔300秒
- 16+个任务：检测间隔600秒

### 2. 录制优化

- **使用`-c copy`**：直接复制流，不重新编码（最高效）
- **分段录制**：长时间直播建议每30分钟一段
- **磁盘空间**：确保至少有50GB可用空间

### 3. 系统资源

**最低配置**：
- CPU：双核
- 内存：4GB
- 磁盘：100GB

**推荐配置**：
- CPU：四核+
- 内存：8GB+
- 磁盘：500GB+ SSD

### 4. 并发限制

**建议同时录制任务数**：
- 低配置：1-3个
- 中配置：4-8个
- 高配置：10+个

---

## 🛠️ 开发与扩展

### 1. 添加新平台支持

**步骤**：

1. 在 `app/core/platform_handlers/handlers.py` 添加处理器：
```python
class NewPlatformHandler(PlatformHandler):
    platform = "newplatform"
    
    async def get_stream_info(self, live_url):
        # 实现平台特定逻辑
        ...
        return StreamData(...)
```

2. 在 `PLATFORM_HANDLERS` 字典中注册：
```python
PLATFORM_HANDLERS = {
    ...
    "newplatform": NewPlatformHandler,
}
```

3. 更新平台识别逻辑。

### 2. 自定义FFmpeg参数

创建新的构建器：
```python
class CustomVideoBuilder(VideoBuilder):
    def _build_codec_args(self):
        # 自定义编码参数
        return [
            '-c:v', 'libx264',
            '-preset', 'ultrafast',
            '-crf', '23'
        ]
```

### 3. 扩展UI组件

创建新的页面或组件：
```python
class CustomPage(PageBase):
    def __init__(self, app):
        super().__init__(app)
        self.page_name = "custom"
    
    async def load(self):
        # 实现页面加载逻辑
        ...
```

### 4. 添加消息推送方式

在 `app/messages/message_pusher.py` 中添加：
```python
class CustomNotifier:
    def send_notification(self, title, content):
        # 实现推送逻辑
        ...
```

---

## 📝 API文档（内部）

### RecordingManager API

#### `add_recording(recording: Recording)`
添加录制任务。

#### `remove_recording(recording: Recording)`
删除录制任务。

#### `start_monitor_recording(recording: Recording)`
开始监控单个任务。

#### `stop_monitor_recording(recording: Recording)`
停止监控单个任务。

#### `start_monitor_recordings()`
批量开始监控。

#### `stop_monitor_recordings()`
批量停止监控。

### LiveStreamRecorder API

#### `start_recording()`
启动录制。

#### `stop_recording()`
停止录制。

#### `get_filename(stream_info: StreamData) -> str`
生成文件名。

#### `get_output_dir(stream_info: StreamData) -> str`
获取输出目录。

### BarrageManager API

#### `start_recording(recording: Recording, live_id: str)`
启动弹幕录制。

#### `stop_recording(recording: Recording)`
停止弹幕录制。

---

## 🎓 学习资源

### 相关技术文档

- [Flet官方文档](https://flet.dev/docs/)
- [FFmpeg文档](https://ffmpeg.org/documentation.html)
- [Protobuf文档](https://protobuf.dev/)
- [StreamGet项目](https://github.com/ihmily/streamget)

### 推荐阅读

- Python异步编程（asyncio）
- 多进程与多线程
- WebSocket协议
- 流媒体技术
- UI设计模式

---

## 🤝 贡献指南

### 如何贡献

1. Fork项目
2. 创建特性分支：`git checkout -b feature/新功能`
3. 提交更改：`git commit -am '添加新功能'`
4. 推送分支：`git push origin feature/新功能`
5. 提交Pull Request

### 代码规范

- 遵循PEP 8
- 添加类型注解
- 编写文档字符串
- 添加单元测试

---

## 📄 许可证

本项目采用 Apache License 2.0 许可证。详见 [LICENSE](./LICENSE) 文件。

---

## 🙏 致谢

感谢以下开源项目：
- [Flet](https://github.com/flet-dev/flet) - UI框架
- [FFmpeg](https://ffmpeg.org) - 多媒体处理
- [StreamGet](https://github.com/ihmily/streamget) - 流地址解析

---

## 📞 联系方式

- **GitHub Issues**: [提交问题](https://github.com/ihmily/StreamCap/issues)
- **Wiki**: [项目文档](https://github.com/ihmily/StreamCap/wiki)

---

## 📊 总结

**V2StreamCap** 是一个功能强大的直播录制工具，核心优势在于：

### 核心特性

1. **自动化**
   - 无需人工值守
   - 自动检测开播
   - 自动开始/停止录制
   - 自动转码优化

2. **多平台支持**
   - 40+国内外平台
   - 统一接口设计
   - 易于扩展

3. **高效录制**
   - FFmpeg直接复制流
   - 不重新编码（节省资源）
   - 支持分段录制
   - 支持多任务并发

4. **数据完整**
   - 同时保存视频和弹幕
   - 捕获礼物和互动
   - 记录购物行为（抖音）
   - 完整的直播数据归档

5. **易用性**
   - 图形化界面
   - 简单配置
   - 实时状态监控
   - 跨平台运行

### 技术亮点

- **事件驱动架构**：响应式设计，高效处理异步事件
- **异步处理**：基于asyncio，支持高并发
- **进程管理**：优雅的子进程控制和清理
- **模块化设计**：清晰的分层架构，易于维护和扩展
- **错误处理**：完善的异常捕获和日志记录

### 适用场景

- 个人使用：收藏喜欢的直播内容
- 内容创作：素材收集和二次创作
- 数据分析：电商直播数据研究
- 学习研究：Python项目学习案例

---

**本技术指南涵盖了V2StreamCap项目的核心技术、架构设计、使用方法和扩展开发等方面，是理解和使用该项目的完整参考文档。**

如有任何问题或建议，欢迎通过GitHub Issues反馈！

